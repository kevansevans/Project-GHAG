Class ElementPunch : Weapon
{
	
	Default
	{
		Weapon.SlotNumber 1;
		Weapon.kickback 150;
	}
	
	Action void A_JumpToPunch() 
	{
		
	}
	
	Action void A_CyclePunchMode()
	{
		Gardevoir(self).PunchMode = (Gardevoir(self).PunchMode + 1) % 3;
		A_PrintPunchMode();
	}
	
	Action void A_PrintPunchMode()
	{
		switch (Gardevoir(self).PunchMode) {
			case 0:
				A_Print("Mega Punch");
				break;
			case 1:
				A_Print("Ice Punch");
				break;
			case 2: 
				A_Print("Fire Punch");
				break;
		}
	}
	
	//Can't figure out how to override A_ExplosivePunch, so this will have to do for now
	Action void A_ExplosivePunch(int damage, bool norandom = false, int flags = CPF_USEAMMO, class<Actor> pufftype = "BulletPuff", double range = 0, double lifesteal = 0, int lifestealmax = 0, class<BasicArmorBonus> armorbonustype = "ArmorBonus", sound MeleeSound = 0, sound MissSound = "")
	{
		let player = self.player;
		if (!player) return;

		let weapon = player.ReadyWeapon;

		double angle;
		double pitch;
		FTranslatedLineTarget t;
		int			actualdamage;

		if (!norandom)
			damage *= random[cwpunch](1, 8);

		angle = self.Angle + random2[cwpunch]() * (5.625 / 256);
		if (range == 0) range = DEFMELEERANGE;
		pitch = AimLineAttack (angle, range, t, 0., ALF_CHECK3D);

		// only use ammo when actually hitting something!
		if ((flags & CPF_USEAMMO) && t.linetarget && weapon && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weapon.DepleteAmmo(weapon.bAltFire, true))
				return;	// out of ammo
		}

		if (pufftype == NULL)
			pufftype = 'BulletPuff';
		int puffFlags = LAF_ISMELEEATTACK | ((flags & CPF_NORANDOMPUFFZ) ? LAF_NORANDOMPUFFZ : 0);

		Actor puff;
		[puff, actualdamage] = LineAttack (angle, range, pitch, damage, 'Melee', pufftype, puffFlags, t);

		if (!t.linetarget)
		{
			if (MissSound) A_StartSound(MissSound, CHAN_WEAPON);
		}
		else
		{
			
			A_BlastLOS(BF_AFFECTBOSSES | BF_DONTWARN, 255, 256 * Gardevoir(self).GetRageModifier(), 20 * Gardevoir(self).GetRageModifier(), pufftype, damage);
			
			if (lifesteal > 0 && !(t.linetarget.bDontDrain))
			{
				if (flags & CPF_STEALARMOR)
				{
					if (armorbonustype == NULL)
					{
						armorbonustype = 'ArmorBonus';
					}
					if (armorbonustype != NULL)
					{
						let armorbonus = BasicArmorBonus(Spawn(armorbonustype));
						if (armorbonus)
						{
							armorbonus.SaveAmount *= int(actualdamage * lifesteal);
							if (lifestealmax > 0) armorbonus.MaxSaveAmount = lifestealmax;
							armorbonus.bDropped = true;
							armorbonus.ClearCounters();

							if (!armorbonus.CallTryPickup(self))
							{
								armorbonus.Destroy ();
							}
						}
					}
				}
				else
				{
					GiveBody (int(actualdamage * lifesteal), lifestealmax);
				}
			}
			if (weapon != NULL)
			{
				if (MeleeSound) A_StartSound(MeleeSound, CHAN_WEAPON);
				else			A_StartSound(weapon.AttackSound, CHAN_WEAPON);
			}

			if (!(flags & CPF_NOTURN))
			{
				// turn to face target
				self.Angle = t.angleFromSource;
			}

			if (flags & CPF_PULLIN) self.bJustAttacked = true;
			if (flags & CPF_DAGGER) t.linetarget.DaggerAlert (self);
		}
	}
	
	action void A_BlastLOS(int blastflags = 0, double strength = 255, double radius = 255, double speed = 20, class<Actor> blasteffect = "BlastEffect", int _damage = 0, sound blastsound = "BlastRadius")
	{

		if (player && (blastflags & BF_USEAMMO) && invoker == player.ReadyWeapon && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			Weapon weapon = player.ReadyWeapon;
			if (weapon != null && !weapon.DepleteAmmo(weapon.bAltFire))
			{
				return;
			}
		}

		A_StartSound (blastsound, CHAN_AUTO);

		if (!(blastflags & BF_DONTWARN))
		{
			SoundAlert (self);
		}
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		while ( (mo = Actor(it.Next ())) )
		{
			if (mo == self || (mo.bBoss && !(blastflags & BF_AFFECTBOSSES)) || mo.bDormant || mo.bDontBlast)
			{ // Not a valid monster: originator, boss, dormant, or otherwise protected
				continue;
			}
			if (mo.bIceCorpse || mo.bCanBlast)
			{
				// Let these special cases go
			}
			else if (mo.bIsMonster && mo.health <= 0)
			{
				continue;
			}
			else if (!mo.player && !mo.bMissile && !mo.bIsMonster && !mo.bCanBlast && !mo.bTouchy && !mo.bVulnerable)
			{	// Must be monster, player, missile, touchy or vulnerable
				continue;
			}
			if (Distance2D(mo) > radius)
			{ // Out of range
				continue;
			}
			if (mo.CurSector.PortalGroup != CurSector.PortalGroup && !CheckSight(mo))
			{
				// in another region and cannot be seen.
				continue;
			}
			
			Actor victim = mo;
			
			double ang = AngleTo(victim);
			Vector2 move = AngleToVector(ang, speed);
			victim.Vel.XY = move;

			ang -= 180.;
			Vector3 spawnpos = victim.Vec3Offset(
				(victim.radius + 1) * cos(ang),
				(victim.radius + 1) * sin(ang),
				(victim.Height / 2) - victim.Floorclip);
			Actor mo = blasteffect? Spawn (blasteffect, spawnpos, ALLOW_REPLACE) : null;
			if (mo)
			{
				mo.Vel.XY = victim.Vel.XY;
			}
			if (victim.bMissile)
			{
				// [RH] Floor and ceiling huggers should not be blasted vertically.
				if (!victim.bFloorHugger && !victim.bCeilingHugger)
				{
					victim.Vel.Z = 8;
					if (mo != null) mo.Vel.Z = 8;
				}
			}
			else
			{
				victim.Vel.Z = 1000. / victim.Mass;
				if (victim.health - _damage <= 0 && blasteffect == "IcePuff") {
					if (!victim.bICECORPSE) victim.SetStateLabel("GenericFreezeDeath");
					else {
						victim.bArmed = false;
						victim.DamageMobj(self, self, victim.health, 'Melee', DMG_FORCED|DMG_EXPLOSION);
					}
				} else {
					victim.DamageMobj(self, self, _damage, 'Melee');
				}
			}
			if (victim.bTouchy)
			{
				victim.bArmed = false;
				victim.DamageMobj(self, self, victim.health, 'Melee', DMG_FORCED|DMG_EXPLOSION);
			}
		}
	}
	
	Action void A_MegaPunch() 
	{
		Invoker.kickback = 150 + (500 * Gardevoir(self).GetRageModifier());
		A_ExplosivePunch(80 + (160 * Gardevoir(self).GetRageModifier()), true, CPF_NOTURN, "MegaPuff", 64 + (64 * Gardevoir(self).GetRageModifier()), 0, 0, "", "attack/CONTACT");
	}
	
	Action void A_IcePunch() 
	{
		Invoker.kickback = 100 + (300 * Gardevoir(self).GetRageModifier());
		A_ExplosivePunch(60 + (120 * Gardevoir(self).GetRageModifier()), true, CPF_NOTURN, "IcePuff", 64 + (64 * Gardevoir(self).GetRageModifier()), 0, 0, "", "attack/CONTACT");
	}
	
	Action void A_FirePunch() 
	{
		Invoker.kickback = 100 + (300 * Gardevoir(self).GetRageModifier());
		A_ExplosivePunch(60 + (120 * Gardevoir(self).GetRageModifier()), true, CPF_NOTURN, "FirePuff", 64 + (64 * Gardevoir(self).GetRageModifier()), 0, 0, "", "attack/CONTACT");
	}
	
	States {
		Select :
			MPUN A 1 A_Raise();
			Loop;
		Deselect :
			MPUN A 1 A_Lower();
			Loop;
		Ready :
			TNT1 A 0 {
				switch (Gardevoir(self).PunchMode) {
					case 0:
						return ResolveState("Ready.Mega");
					case 1:
						return ResolveState("Ready.Ice");
					case 2:
						return ResolveState("Ready.Fire");
				}
				return ResolveState(null);
			}
		Ready.Mega :
			MPUN A 1 A_WeaponReady(WRF_ALLOWRELOAD);
			Loop;
		Ready.Ice :
			IPUN A 1 A_WeaponReady(WRF_ALLOWRELOAD);
			Loop;
		Ready.Fire :
			FPUN A 1 A_WeaponReady(WRF_ALLOWRELOAD);
			Loop;
		Reload : 
			#### # 0 A_CyclePunchMode();
			#### # 2 offset(0, 0);
			#### # 2 offset(0, 30);
			#### # 2 offset(0, 60);
			#### # 2 offset(0, 90);
			#### # 2 offset(0, 120);
			#### # 2 offset(0, 150);
			TNT1 A 0 {
				switch (Gardevoir(self).PunchMode) {
					case 0:
						return ResolveState("Reload.Mega");
					case 1:
						return ResolveState("Reload.Ice");
					case 2:
						return ResolveState("Reload.Fire");
				}
				return ResolveState(null);
			}
		Reload.Mega :
			MPUN A 0 A_WeaponReady(WRF_ALLOWRELOAD);
			goto Reload.Resume;
		Reload.Ice:
			IPUN A 0 A_WeaponReady(WRF_ALLOWRELOAD | WRF_NOBOB);
			goto Reload.Resume;
		Reload.Fire:
			FPUN A 0 A_WeaponReady(WRF_ALLOWRELOAD | WRF_NOBOB);
			goto Reload.Resume;
		Reload.Resume:
			#### # 2 offset(0, 150) A_WeaponReady(WRF_ALLOWRELOAD | WRF_NOBOB);
			#### # 2 offset(0, 120) A_WeaponReady(WRF_ALLOWRELOAD | WRF_NOBOB);
			#### # 2 offset(0, 90) A_WeaponReady(WRF_ALLOWRELOAD | WRF_NOBOB);
			#### # 2 offset(0, 60) A_WeaponReady(WRF_ALLOWRELOAD | WRF_NOBOB);
			#### # 2 offset(0, 30) A_WeaponReady(WRF_ALLOWRELOAD | WRF_NOBOB);
			#### # 2 offset(0, 0) A_WeaponReady(WRF_ALLOWRELOAD | WRF_NOBOB);
			goto Ready;
		Fire :
			#### # 2 {
			
				Gardevoir(self).RageValue -= 10;
				if (Gardevoir(self).RageValue < 0) Gardevoir(self).RageValue = 0;
			
				switch (Gardevoir(self).PunchMode) {
					case 0:
						return ResolveState("Fire.Mega");
					case 1:
						return ResolveState("Fire.Ice");
					case 2:
						return ResolveState("Fire.Fire");
				}
				return ResolveState(null);
			}
		Fire.Mega:
			TNT1 A 0 A_PlaySound("fists/MEGAPNCH", CHAN_BODY, 0.25);
			TNT1 A 0 A_Jump(127, "Fire.Mega.Lefty");
		Fire.Mega.Righty:
			MPUN BC 3 A_SetTics(Gardevoir(self).GetTicModifier(3));
			MPUN D 4 A_MegaPunch();
			MPUN EFG 4 {
				A_WeaponReady(WRF_NOFIRE | WRF_ALLOWRELOAD);
				A_SetTics(Gardevoir(self).GetTicModifier(4));
			}
			MPUN A 1 A_Refire();
			goto Ready;
		Fire.Mega.Lefty:
			MPUN HI 3 A_SetTics(Gardevoir(self).GetTicModifier(3));
			MPUN J 4 A_MegaPunch();
			MPUN KLM 4 {
				A_WeaponReady(WRF_NOFIRE | WRF_ALLOWRELOAD);
				A_SetTics(Gardevoir(self).GetTicModifier(4));
			}
			MPUN A 1 A_Refire();
			goto Ready;
		Fire.Ice:
			TNT1 A 0 A_PlaySound("fists/ICEPUNCH", CHAN_BODY, 0.25);
			TNT1 A 0 A_Jump(127, "Fire.Ice.Lefty");
		Fire.Ice.Righty:
			IPUN BC 3 A_SetTics(Gardevoir(self).GetTicModifier(3));
			IPUN D 4 A_IcePunch();
			IPUN EFG 4 {
				A_WeaponReady(WRF_NOFIRE | WRF_ALLOWRELOAD);
				A_SetTics(Gardevoir(self).GetTicModifier(4));
			}
			IPUN A 1 A_Refire();
			goto Ready;
		Fire.Ice.Lefty:
			IPUN HI 3 A_SetTics(Gardevoir(self).GetTicModifier(3));
			IPUN J 4 A_IcePunch();
			IPUN KLM 4 {
				A_WeaponReady(WRF_NOFIRE | WRF_ALLOWRELOAD);
				A_SetTics(Gardevoir(self).GetTicModifier(4));
			}
			IPUN A 1 A_Refire();
			goto Ready;
		Fire.Fire:
			TNT1 A 0 A_PlaySound("fists/FIREPNCH", CHAN_BODY, 0.25);
			TNT1 A 0 A_Jump(127, "Fire.Fire.Lefty");
		Fire.Fire.Righty:
			FPUN BC 3 A_SetTics(Gardevoir(self).GetTicModifier(3));
			FPUN D 4 A_FirePunch();
			FPUN EFG 4 {
				A_WeaponReady(WRF_NOFIRE | WRF_ALLOWRELOAD);
				A_SetTics(Gardevoir(self).GetTicModifier(4));
			}
			FPUN A 1 A_Refire();
			goto Ready;
		Fire.Fire.Lefty:
			FPUN HI 3 A_SetTics(Gardevoir(self).GetTicModifier(3));
			FPUN J 4 A_FirePunch();
			FPUN KLM 4 {
				A_WeaponReady(WRF_NOFIRE | WRF_ALLOWRELOAD);
				A_SetTics(Gardevoir(self).GetTicModifier(4));
			}
			FPUN A 1 A_Refire();
			goto Ready;
	}
}

Class BasePunchPuff : BulletPuff
{
	Default {
		+PUFFONACTORS;
		+HITTARGET;
		-RANDOMIZE;
		VSpeed 0;
		Alpha 1;
	}
	
	override void tick() {
	
		if (target) {
			Vector3 follow = target.pos;
			follow.z += (target.height / 3) * 2.0;
			SetXYZ(follow);
		}
		
		Super.tick();
	}
}

Class MegaPuff : BasePunchPuff
{
	States
	{
		Spawn:
		Melee:
			MPUF BABABA 4 Bright;
		Death:
			stop;
	}
}

Class IcePuff : BasePunchPuff
{
	Default
	{
		DamageType "Ice";
	}	
	
	States
	{
		Spawn :
		Melee :
			IPFA ABCDEFGHIJKLMNOPQRSTUVWXYZ 1 Bright;
			IPFB ABCDEFGHIJKLM 1 Bright;
			IPFB K 1 Bright;
			IPFB NO 1 Bright;
			IPFB K 1 Bright;
			TNT1 A 1 Bright;
			IPFB K 1 Bright;
			IPFB L 1 Bright;
			IPFB K 1 Bright;
			TNT1 A 2 Bright;
			IPFB K 5 Bright;
			stop;
			
	}
}

Class FirePuff : BasePunchPuff
{
	Default
	{
		DamageType "Fire";
	}
	States
	{
		Spawn :
			TNT1 A 0 {
				A_FaceTarget();
				A_VileTarget();
			}
		Melee :
			FIRE BCBC 4 bright {
				if (target) SetXYZ(target.pos);
			}
			TNT1 A 0 {
				if (target) {
					if (random(1, 100) <= 25) return ResolveState("Burn");
				}
				return ResolveState(null);
			}
			stop;
		Burn :
			FIRE CDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDC 1 {
				SetXYZ(target.pos);
				A_Fire();
				A_CustomMeleeAttack(random(7, 13));
				if (target.health <= 0) return ResolveState("Death");
				else return ResolveState(null);
			}
			TNT1 A 0 A_Jump(63, "Burn");
		Death:
			stop;
		
	}
}