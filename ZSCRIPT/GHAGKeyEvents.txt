class GHAGKeyEvents : EventHandler
{   
	override bool InputProcess (InputEvent e)
	{
		if (e.Type == InputEvent.Type_KeyDown)
			SendNetworkEvent("KinesisActivate", e.KeyScan); 
		if (e.Type == InputEvent.Type_KeyUp)
			SendNetworkEvent("KinesisDeactivate", e.KeyScan); 
		return false;
   }

   override void NetworkProcess(ConsoleEvent e)
   {               
		if (e.Name == "KinesisActivate")  
		{
			let gardie = Gardevoir(players[consoleplayer].mo);
		
			int key1, key2;
			[key1, key2] = Bindings.GetKeysForCommand("kinesis");
			if ((key1 && key1 == e.Args[0]) || (key2 && key2 == e.Args[0]))
			{
				FLineTraceData shot;
				int kinesis_distance = 32;
				
				Array<Actor> list;
				
				int iterations = 0;
				
				while (kinesis_distance < 2048)
				{
					gardie.LineTrace(gardie.angle, kinesis_distance, gardie.pitch, TRF_THRUACTORS | TRF_THRUHITSCAN, gardie.height - 12, 0, 0, shot);
					
					let blast = KinesisBlast(Actor.spawn('KinesisBlast', shot.HitLocation));
					blast.getRadialActors();
					list.copy(blast.list);
					
					if (list.size() != 0)
					{
						blast.startpulling = true;
						break;
					}
					
					kinesis_distance += 32;
					++iterations;
				}
			}
		}
	}
}

Class KinesisBlast : Actor
{

	Array<Actor> list;
	bool startPulling;
	bool slapProjectile;

	void getRadialActors()
	{
		list.clear();
		
		int radial = 64;
		
		let gardie = Gardevoir(players[consoleplayer].mo);
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		while ( (mo = Actor(it.Next ())) )
		{
			if (mo is 'KinesisPing') continue;
			if (mo is 'BulletPuff') continue;
			if (mo is 'Blood') continue;
			if (mo == self || mo is 'KinesisBlast') continue;
			if (mo is 'Gardevoir') continue;
			if (mo.bCorpse) continue;
			if (mo.bIsMonster) continue;
			if (!gardie.isVisible(mo, false)) continue;
			if (gardie.distance3D(mo) < 64) continue;
			if (mo is "BossTarget" || mo is "BossEye" || (mo is "Rocket" && !(mo.target))) continue;
			if (mo is "TeleportDest") continue;
			if (mo is "lightningfizzle") continue;
			if (Inventory(mo)) {
				if (Inventory(mo) && Inventory(mo).owner is "PlayerPawn") continue;
			}
			if (distance3D(mo) <= radial) {
			
				if (radial == 64) 
				{	
					it.Reinit();
					list.clear();
					radial = 256;
				}
			
				if (!mo.bMissile) 
				{
					list.push(mo);
					KinesisPing(Actor.spawn('KinesisPing', mo.pos));
				}
				
				if (mo.bMissile && gardie.distance3D(mo) <= 512)
				{
					if (mo.target)
					{
						KinesisPing(Actor.spawn('KinesisPing', mo.pos));
					
						mo.tracer = mo.target;
						mo.target = gardie;
						
						mo.angle *= -1;
						mo.pitch *= -1;
						mo.Vel3DFromAngle(mo.speed * 2, angleTo(mo.tracer), mo.pitch);
						mo.speed *= 2;
						
						mo.bSeekerMissile = true;
						mo.bThruSpecies = false;
						mo.bScreenSeeker = true;
						mo.A_SeekerMissile(360, 15, SMF_LOOK | SMF_PRECISE);
					}
				}
			}
		}
	}
	
	void ReturnToSender()
	{
		let gardie = Gardevoir(players[consoleplayer].mo);
		
		for (int i = 0; i < list.size(); ++i)
		{
			if (!list[i]) {
				list.delete(i--);
				list.shrinkToFit();
				continue;
			}
			else
			{
				Actor victim = list[i];
				
				if (ExplosiveBarrel(victim))
				{
					if (!victim.InStateSequence(victim.CurState, victim.ResolveState("Death")))
					{
						if (!victim.tracer)
						{
							victim.target = gardie;
							victim.bMissile = true;
							victim.bNoExplodeFloor = true;
							victim.bSeekerMissile = true;
							victim.bRollSprite = true;
							victim.bRollCenter = true;
							for (int i = 0; i < 10; ++ i) victim.A_SeekerMissile(360, 90, SMF_LOOK | SMF_PRECISE);
							KinesisPing(Actor.spawn('KinesisPing', victim.pos));
							if (victim.tracer)
							{
								victim.A_SeekerMissile(360, 90, SMF_LOOK | SMF_PRECISE);
								victim.A_SetRoll(victim.roll + 25, SPF_INTERPOLATE);
							} 
							else
							{
								victim.bMissile = false;
								victim.damageMobj(victim, victim, 9999999, '');
								list.delete(i--);
								list.shrinkToFit();
							}
						}
						else
						{
							victim.Vel3DFromAngle(40, victim.angleTo(victim.tracer), 0);
							victim.A_SetRoll(victim.roll + 25, SPF_INTERPOLATE);
						}
					}
					else
					{
						list.delete(i--);
						list.shrinkToFit();
					}
					continue;
				}
				
				if (Inventory(victim))
				{
					Inventory(victim).bNoCLip = true;
				}
	
				if (gametic % 2 == 0)
				{
					double angle = gardie.AngleTo(victim);
					Vector2 move = gardie.AngleToVector(angle, -32);
					victim.Vel.XY = move;
					victim.Vel.Z = 64. / victim.Mass;
					
					if (gardie.distance2D(victim) <= 64)
					{
						if (Inventory(victim))
						{
							if (RageEssence(Victim))
							{
								int rage = gardie.GetRageValue();
								if (rage < gardie.rageconstant) Inventory(victim).touch(gardie);
							} 
							else 
							{
								Inventory(victim).touch(gardie);
							}
							if (victim) {
								victim.bNoClip = false;
								victim.vel = (0, 0, 0);
							}
						}
						list.delete(i);
						list.ShrinkToFit();
					}
				}
			}
		}
	}
	
	default
	{
		+NoGravity;
	}
	
	states
	{
		Spawn:
			TNT1 A 1 Bright
			{
				if (invoker.startpulling) self.returnToSender();
				if (invoker.list.size() == 0) self.destroy();
			}
			loop;
	}
}

Class KinesisPing : Actor
{
	States
	{
		Spawn :
			TNT1 A 4 A_SetTics(Random(1, 3));
			PING ABCDEFGHIJKLMN 1 Bright;
			Stop;
	}
}