Class Gardevoir : PlayerPawn
{
	int RageTimer;
	int RageConstant;
	int RageValue;
	double RageBonus;
	
	bool OverTheEdge;
	bool charonmode;
	bool chargingBlackHole;
	//property charonmode: charonmode;
	
	PointLight glowy;
	
	default {
		Health 350;
		PainChance 255;
        Player.DisplayName "Gardevoir";
		
		Player.StartItem "GHAGPistol";
		Player.StartItem "GHAGPistolOverlay";
		Player.StartItem "Clip", 100;
		Player.StartItem "Shell", 0;
		Player.StartItem "RocketAmmo", 0;
		Player.StartItem "Cell", 0;
		
		Player.StartItem "IcePunch";
		Player.StartItem "Swift";
		Player.StartItem "MoonBlastGun";
		Player.StartItem "BlackHole";
		Player.MaxHealth 350;
		
		Player.ForwardMove 2, 1;
		
		xscale 0.325;
		yscale 0.325;
	}
	
	States
	{
		Spawn:
			GARD BCBA 16;
			Loop;
		See:
			GARD BCBA 6;
			TNT1 A 0 A_GetSwayDirection();
			Loop;
		see.SwayForward:
			GARD BCBA 6;
			TNT1 A 0 A_GetSwayDirection();
			goto See;
		See.SwayLeft:
			GARD A 6;
			TNT1 A 0 A_GetSwayDirection();
			goto See;
		See.SwayRight:
			GARD C 6;
			TNT1 A 0 A_GetSwayDirection();
			goto See;
		Pain:
			GARD P 8;
			Goto Spawn;
		Missile:
		Melee:
			GARD F 10
			{
				if (!invoker.glowy)
				{
					Vector3 lightpos = (self.pos.x, self.pos.y, self.pos.z + 50);
					invoker.glowy = Pointlight(self.spawn("PointLight", lightpos));
					invoker.glowy.args[0] = 0x6A;
					invoker.glowy.args[1] = 0x06;
					invoker.glowy.args[2] = 0xAD;
					invoker.glowy.args[3] = 16;
				}
			}
			TNT1 A 0
			{
				invoker.glowy.destroy();
			}
			goto spawn;
		Death:
			GARD A 1
			{
				A_SetRenderStyle(1, STYLE_Stencil);
				SetShade("FF0000");
			}
		Death.Shrink:
			GARD A 4 A_JumpIf(A_Shrink(), "Death.Loop");
			loop;
		Death.Loop:
			TNT1 A 0 A_SetScale(1);
			PBAL B 16;
			TNT1 A 0 A_StartSound("pokeball/Shake", CHAN_BODY, CHANF_OVERLAP);
			PBAL BFB 4;
			PBAL B 16;
			TNT1 A 0 A_StartSound("pokeball/Shake", CHAN_BODY, CHANF_OVERLAP);
			PBAL BEB 4;
			loop;
	}
	
	Action bool A_Shrink()
	{
		if (scale.x > 0.1)
		{
			A_SetScale(scale.x - 0.05);
			return false;
		} else {
			A_SetRenderStyle(1, STYLE_Normal);
			return true;
		}
	}
	
	Action state A_GetSwayDirection()
	{
		double thresh = 3;
	
		double x_dir = self.vel.x * cos(self.angle) - self.vel.y * sin(angle);
		double y_dir = self.vel.x * sin(self.angle) + self.vel.y * cos(angle);
		
		if (y_dir >= thresh) return resolveState('see.SwayLeft');
		else if (y_dir <= -thresh) return resolveState('see.SwayRight');
		else if (x_dir > thresh || x_dir < -thresh) return resolveState('see.SwayForward');
		
		return resolveState('see');
	}
	
	override void BeginPlay()
	{
		Super.BeginPlay();
		
		RageValue = 0;
		Ragetimer = 0;
		RageConstant = 200;
		RageBonus = 0;
		
		OverTheEdge = false;
		charonmode = false;
	}
	
	void subtractAnger(Int value)
	{
		if (OverTheEdge) return;
		
		RageValue -= value;
		if (RageValue < 0) RageValue = 0;
	}
	
	void addAnger(Int value)
	{
		if (OverTheEdge) return;
		
		RageValue += value;
		if (RageValue > RageConstant) RageValue = RageConstant;
	}
	
	int rollCounterAnger;
	void IncreaseAngerRange(Int value)
	{
		rollCounterAnger += value;
	}
	
	void GetLivid()
	{
		if (!overTheEdge) RageValue += 750;
		else RageValue += 250;
		RageBonus += 0.34;
	}
	
	int GetRageValue() {
		return RageValue;
	}
	
	double GetRageModifier()
	{
		return GetRageValue() * 0.001 * (v_dashed ? 3 : 1);
	}
	
	double GetTicModifier(int tic, bool allowZero = false, int weight = -1) 
	{
		int tics = weight == -1 ? tic : weight;
		double value = tics * (1 - GetRageModifier());
		if (!allowZero) {
			if (value < 1) value = 1;
		}
		value = round(value);
		if (weight != -1) value = min(tic, value);
		return Max(value, 0);
	}
	
	double GetDamageModifier(double damage)
	{
		return damage + (damage * GetRageModifier());
	}
	
	double GetAccuracyModifier(double accuracy)
	{
		return min(max(1, accuracy * (1 - GetRageModifier())), 20);
	}
	
	int restore_kaboom;
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		int _locDamage = damage;
		int _locFlags = flags;
		
		if (RageValue <= RageConstant) {
		
			RageValue += int(damage / 5);
		
			RageTimer = 0;
			if (RageValue > RageConstant) RageValue = RageConstant;
		}
		
		/*if (!Gardevoir(source)) ActorTracker.trackThing(Source, NONE, damage);
		else
		{
			_locDamage *= 0.25;
		}*/
		
		if (Gardevoir(source)) _locDamage *= 0.25;
		
		if (_locDamage >= 5)
		{
			A_StartSound("gardie/Pain", CHAN_AUTO, 0, min(3, (double(_locdamage / 10.0))));
		}
		
		return Super.DamageMobj(inflictor, source, _locDamage, mod, _locFlags, angle);
	}
	
	override void Tick()
	{
		if (self.glowy)
		{
			Vector3 lightpos = (self.pos.x, self.pos.y, self.pos.z + 50);
			self.glowy.setOrigin(lightpos, true);
		}
	
		////////////////////////////////////////////////////////////////////////////////////////////////////
		//Rage cooldown
		////////////////////////////////////////////////////////////////////////////////////////////////////
		RageTimer++;
		
		if (rollCounterAnger > 0 && gametic % 2 == 0) {
			RageConstant += 1;
			rollCounterAnger -= 1;
		}
		
		if (RageValue > RageConstant) OverTheEdge = true;
		else if (RageValue <= RageConstant) OverTheEdge = false;
		
		if (rageValue != 0)
		{
			if (!overTheEdge)
			{
				int draintic = int(100 / (rageValue / 10. / 2.)) * 2;
				int drainrate = 1;
				if (ragevalue > 1000 && !overTheEdge)
				{
					int rate = int((ragevalue - 1000) / 100 / 2);
					drainrate += rate;
				}
				if (RageTimer >= (draintic + int(RageBonus))) {
					ragevalue -= drainrate;
					RageTimer = 0;
				}
			} else if (overTheEdge) {
				if (RageTimer >= (10 + int(RageBonus))) {
					ragevalue -= 3;
					RageTimer = 0;
				}
			}
		}
		
		////////////////////////////////////////////////////////////////////////////////////////////////////
		//Incorrect inventory handler
		////////////////////////////////////////////////////////////////////////////////////////////////////
		if (self.countinv("Pistol") >= 1)
		{
			self.clearInventory();
			
			self.giveInventory("GHAGPistol", 1);
			self.giveInventory("GHAGPistolOverlay", 1);
			self.giveInventory("IcePunch", 1);
			self.giveInventory("Swift", 1);
			self.giveInventory("MoonBlastGun", 1);
			self.giveInventory("BlackHole", 1);
		}
		
		////////////////////////////////////////////////////////////////////////////////////////////////////
		//Dash handler
		////////////////////////////////////////////////////////////////////////////////////////////////////
		
		if (player)
		{
		let buttons = player.cmd.buttons;
		double theta = 0;
		double speed = 45;
		
		if (buttons & BT_Speed && shift_tic == -1) {
			shift_tic = gametic;
			dashed = false;
		}
		else if (!(buttons & BT_Speed) && shift_tic != -1) {
			shift_tic = -1;
		}
		
		if (!(buttons & BT_Jump)) {
			if (v_dashed) player.cheats &= ~CF_FROZEN;
			v_dashed = false;
		}
		
		if (player.onGround && buttons & BT_Jump) jumped = true;
		else if (player.onGround) {
			jumped = false;
			v_dashed = false;
			A_StopSound(CHAN_BODY);
		}
		
		if (!player.onGround && jumped && buttons & BT_Jump)
		{
			if (!v_dashed && self.vel.z <= 0)
			{
				self.vel.z = 10;
				v_dashed = true;
				player.cheats |= CF_FROZEN;
				A_Blast(BF_ONLYVISIBLETHINGS);
				A_StartSound("dash/Start", CHAN_AUTO);
			}
					
		}
		
		if (v_dashed && self.vel.z <= 0)
		{
			if (holdpos != self.pos) holdpos = self.pos;
			else {
				self.setOrigin(holdpos, false);
			}
			self.vel.z = 0;
			
			if (buttons & BT_Speed)
			{	
				speed = 20;
				
				A_StartSound("dash/AirLoop", CHAN_BODY, CHANF_LOOP | CHANF_NOSTOP);
				
				if (buttons & BT_MoveLeft) {
					theta = 90;
					if (buttons & BT_Forward && !(buttons & BT_Back)) theta -= 45;
					else if (buttons & BT_Back && !(buttons & BT_Forward)) theta += 45;
				}
				else if (buttons & BT_MoveRight) {
					theta = 270;
					if (buttons & BT_Forward && !(buttons & BT_Back)) theta += 45;
					else if (buttons & BT_Back && !(buttons & BT_Forward)) theta -= 45;
				}
				else if (buttons & BT_Back && !(buttons & (BT_MoveRight | BT_MoveLeft))) theta = 180;
					
				theta += (self.angle % 360);
				
				double thrust_x = min(speed * cos(theta), speed);
				double thrust_y = min(speed * sin(theta), speed);
					
				self.vel.x = thrust_x;
				self.vel.y = thrust_y;
				
				if (gametic % 17 == 0) SubtractAnger(15);
			} 
			else
			{
				A_StopSound(CHAN_BODY);
			
				if (self.vel.x > 0.5) self.vel.x -= 0.3;
				else if (self.vel.x < -0.5) self.vel.x += 0.3;
				else self.vel.x = 0;
				
				if (self.vel.y > 0.5) self.vel.y -= 0.3;
				else if (self.vel.y < -0.5) self.vel.y += 0.3;
				else self.vel.y = 0;
			}
		}
		
		if (shift_tic == -1) dash_timer = 0;
		else
		{
			++dash_timer;
			if (dash_timer >= 5 && dashed == false)
			{
				dashed = true;
			
				if (shift_tic != -1)
				{
					theta = 0;
				}
				
				if (!v_dashed)
				{
					if (buttons & BT_MoveLeft) {
						theta = 90;
						if (buttons & BT_Forward && !(buttons & BT_Back)) theta -= 45;
						else if (buttons & BT_Back && !(buttons & BT_Forward)) theta += 45;
					}
					else if (buttons & BT_MoveRight) {
						theta = 270;
						if (buttons & BT_Forward && !(buttons & BT_Back)) theta += 45;
						else if (buttons & BT_Back && !(buttons & BT_Forward)) theta -= 45;
					}
					else if (buttons & BT_Back && !(buttons & (BT_MoveRight | BT_MoveLeft))) theta = 180;
					
					theta += (self.angle % 360);
					
					double thrust_x = speed * cos(theta);
					double thrust_y = speed * sin(theta);
					
					self.vel.x = thrust_x;
					self.vel.y = thrust_y;
					
					A_StartSound("dash/Start", CHAN_AUTO);
				}
			} 
		}
		
		double p_speed = sqrt((self.vel.x * self.vel.x) + (self.vel.y * self.vel.y));
		
		if (p_speed >= 20)
		{
			double r_speed = (p_speed - 20.0) / 20;
			
			FLineTraceData bash;
			if (self.LineTrace(self.angle, 64, self.pitch, 0, self.height - 12, 0, 0, bash))
			{
				double x = bash.HitLocation.x - self.pos.x;
				double y = bash.HitLocation.y - self.pos.y;
				double dist = sqrt((x * x) + (y * y));
				if (bash.hitline)
				{
					
				}
			}
		}
		}
		
		Super.Tick();
	}
	
	//From GZDoom.pk3, just removes the check to see if the level turns of jumping
	override void CheckJump()
	{
		let player = self.player;
		if (player.cmd.buttons & BT_JUMP)
		{
			if (player.crouchoffset != 0)
			{
				player.crouching = 1;
			}
			else if (waterlevel >= 2)
			{
				Vel.Z = 4 * Speed;
			}
			else if (bNoGravity)
			{
				Vel.Z = 3.;
			}
			else if (player.onground && player.jumpTics == 0)
			{
				double jumpvelz = JumpZ * 35 / TICRATE;
				double jumpfac = 0;
				
				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) jumpvelz *= jumpfac;

				Vel.Z += jumpvelz;
				bOnMobj = false;
				player.jumpTics = -1;
				if (!(player.cheats & CF_PREDICTING)) A_StartSound("*jump", CHAN_BODY);
			}
		}
	}
	
	override void PlayerThink()
	{
		super.PlayerThink();
	}
	
	Vector3 holdpos;
	bool dashed;
	bool v_dashed;
	bool jumped;
	int dash_timer;
	int shift_tic;
	
	/*override void GiveInventoryType(class<Inventory> _itemToReceive)
	{
		if (_itemToReceive == "Pistol") 
		{
			super.GiveInventoryType("GHAGPistol");
			return;
		}
		
		if (_itemToReceive == "Fist") 
		{
			Super.giveInventoryType("ElementPunch");
			return;
		}
		
		Super.GiveInventoryType(_itemToReceive);
	}*/
	
	override void CheatGive(String _name, int _amount)
	{
		if (_name == 'all')
		{
			if (RageConstant < 1000) RageConstant = 1000;
			else RageConstant += 100;
			
			RageValue = RageConstant;
			
			super.CheatGive("GHAGBackpack", 40);
			super.CheatGive("GHAGBackpack", 40);
			super.CheatGive("all", _amount);
			return;
		}
		
		super.CheatGive(_name, _amount);
		
	}
	
	override bool OnGiveSecret(bool print, bool playsound)
	{
		bool rtn = super.OnGiveSecret(print, playsound);
		
		//In the situation a sector fails to spawn a secret,
		//we grant a rage candybar to compensate
		if (self.curSector)
		{
			bool bonus = false;
			Actor mo = self.curSector.thinglist;
			while (mo)
			{
				let c = self.curSector.centerspot;
				if (level.IsPointInLevel((c.x, c.y, self.curSector.floorplane.ZAtPoint(c))))
				{
					bonus = true;
					break;
				}
				mo = mo.snext;
			}
			if (!bonus)
			{
				RageCandyBar(Actor.Spawn('RageCandyBar', self.pos)).touch(self);
			}
		}
		
		return rtn;
	}
}

class PlayerRef : Actor
{
	default
	{
	}
	States
	{
		Spawn :
			PLAY A 1 Bright;
			Loop;
	}
}

Class TestVoir : Actor
{
	default
	{
		xscale 0.325;
		yscale 0.325;
	}
	States
	{
		Spawn:
			GARD F 4 Bright;
			Loop;
	}
}