Enum StatusType
{
	NONE = 0,
	FROZEN = 1,
	BURNED = 2,
	PARALYZED = 4,
}

Class StatusEffect : Object
{
	Actor owner;
	int damage;
	int FrozenTimer;
	int prevPainValue;
	int prevTicValue;
	bool Burned;
	bool Paralyzed;
	bool dead;
}

Class ActorTrackerThinker : Thinker
{
	Array<StatusEffect> Effects;
	Array<Actor> Actors;

	ActorTrackerThinker Init()
	{
		ChangeStatNum(STAT_INFO);
		
		Effects.clear();
		Actors.clear();
		
		return self;
	}
	
	static ActorTrackerThinker Get()
	{
		ThinkerIterator it = ThinkerIterator.Create("ActorTrackerThinker",STAT_INFO);
		let p = ActorTrackerThinker(it.Next());
		if (p == null)
		{
			p = new("ActorTrackerThinker").Init();
		}
		return p;
	}
}

Class ActorTracker : EventHandler
{
	static void TrackThing(Actor thing, StatusType Status, int Damage = 0) 
	{
		let tracker = ActorTrackerThinker.get();
		if (!tracker) return;
	
		int index = tracker.Actors.find(thing);
		if (index == tracker.Actors.size()) 
		{
			tracker.Actors.push(thing);
			
			let tempeffect = new("StatusEffect");
			tempeffect.owner = thing;
			tempeffect.damage = 0;
			tempeffect.frozentimer = 0;
			tempeffect.burned = false;
			tempeffect.paralyzed = false;
			tempeffect.dead = false;
			tempeffect.prevPainValue = thing.painchance;
			tempeffect.prevTicValue = 0;
			
			tracker.Effects.push(tempeffect);
			
			index = tracker.Actors.find(thing);
		}
		StatusEffect effect = tracker.Effects[index];
		
		effect.damage += Damage;
		
		if (Status & FROZEN) 
		{
			if (effect.frozentimer == 0) {
				effect.frozentimer = 35 * 5;
				effect.owner.painchance = 0;
			}
		}
		if (Status & BURNED)
		{
			if (!effect.burned) effect.burned = true;
		}
		if (Status & PARALYZED)
		{
			if (!effect.paralyzed) effect.paralyzed = true;
		}
	}
	
	static StatusEffect getActorStats(Actor thing)
	{
		let tracker = ActorTrackerThinker.get();
		if (!tracker) return null;
	
		if (tracker.Actors.find(thing) == tracker.Actors.Size()) return null;
		else return tracker.Effects[tracker.Actors.find(thing)];
	}
	
	override void WorldTick()
	{
		let tracker = ActorTrackerThinker.get();
		if (!tracker) return;
	
		for (int i = 0; i < tracker.Effects.size(); ++i)
		{
			StatusEffect effect = tracker.Effects[i];
			
			if (effect.dead) continue;
			
			Actor thing = effect.owner;
			if (thing.health <= 0 || thing.tics <= -1)
			{
				effect.dead = true;
				
				if (effect.frozentimer > 0) thing.bIceCorpse = true;
				
				//force extra dead effect here just to make sure the actor
				//doesn't show unwanted effects
				continue;
			}
			
			if (effect.frozenTimer > 0) 
			{
				thing.tics = effect.frozenTimer;
				thing.A_SetRenderStyle(0.1, STYLE_STENCIL);
				thing.setShade("c2e0f9");
				effect.frozenTimer -= 1;
				if (effect.frozentimer == 0) {
					thing.setStateLabel("See");
					thing.A_SetRenderStyle(1, STYLE_Normal);
					thing.painchance = effect.prevPainValue;
				}
			}
			
			if (effect.burned) 
			{
				if (gametic % (35 * 2) == 0)
				{
					thing.damagemobj(players[consoleplayer].mo, players[consoleplayer].mo, int(thing.spawnhealth() / 16), "Fire");
					thing.SetStateLabel("Pain");
					
					int rng = random(1, 100);
					if (rng <= 25) effect.burned = false;
				}
			}
			
			if (effect.paralyzed)
			{
				if (effect.prevTicValue < thing.tics)
				{
					thing.tics *= 2;
				}
				effect.prevTicValue = thing.tics;
			}
		}
	}
}