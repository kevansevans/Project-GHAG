Class GHAGPlasmaOverlay : Ammo
{
	Default
	{
		Inventory.MaxAmount 4;
		Inventory.pickupMessage "Found an extra plasma rifle!";
	}
}

Class GHAGPlasmaRifle : PlasmaRifle
{
	default {
		Weapon.SlotNumber 6;
		Tag "Generic Energy Weapon";
		Weapon.AmmoType1 "Cell";
		Weapon.AmmoType2 "Cell";
	}
	
	Array<PsychicPlasma> PlasmaTracker;
	
	override void DoEffect()
	{
		players[consoleplayer].WeaponState |= WF_WEAPONBOBBING;
		super.DoEffect();
	}
	
	override void Tick()
	{
		Super.tick();
	}	
	
	States
	{
		Select:
			HAND A 1 {	
				A_Raise();
				A_PlasmaOverlay();
			}
			loop;
		Deselect:
			HAND A 1 {
				A_Lower();
				A_PlasmaOverlay();
			}
			loop;
		Ready:
			HAND A 1 {
				if (!Gardevoir(players[consoleplayer].mo).blocking) A_WeaponReady();
				A_PlasmaOverlay();
			}
			loop;
		Fire:
			HAND A 1 A_PsychicPlasma();
			HAND BC 1;
			HAND DE 1 A_Refire();
			Goto Ready;
		AltFire:
			TNT1 A 0 A_DetonatePlasma();
			HAND ABCDE 1;
			goto Ready;
		Plasma.Overlay :
			PLSM ABCDE 1;
			Loop;
	}
	
	Action void A_PlasmaOverlay()
	{
		for (int i = 0; i < CountInv("GHAGPlasmaOverlay"); ++ i)
		{
			int layer = -1 * (i + 1);
			A_Overlay(layer, "Plasma.Overlay", false);
			A_OverlayFlags(layer, PSPF_ADDBOB, false);
			if ((i + 1) % 2 == 0) A_OverlayFlags(layer, PSPF_FLIP | PSPF_MIRROR, true);
			A_OverlayOffset(layer, (sin(gametic + (72 * i))) + (45 * (i / 2)) + 30, (cos(gametic + (72 * i))) - (55 * (i / 2)) + (i < 2 ? 5 : 0), WOF_INTERPOLATE);
		}
	}
	
	Action void A_PsychicPlasma() {
		for (int i = 0; i < CountInv("GHAGPlasmaOverlay"); ++i)
		{
			if (player == null)
			{
				return;
			}
			Weapon weap = player.ReadyWeapon;
			int gun = i + 1;
			int x = 15;
			if (gun == 2) x = -15;
			else if (gun == 3) x = 20;
			else if (gun == 4) x = -20;
			let _locPlasma = PsychicPlasma(A_FireAimedProjectile("PsychicPlasma", i == 0 ? true : false, x, gun > 2 ? 12 : 5));
			if (_locPlasma) {
				invoker.PlasmaTracker.push(_locPlasma);
			}
		}
	}
	
	Action void A_DetonatePlasma()
	{
		for (int a = 0; a < invoker.PlasmaTracker.Size(); ++a)
		{
			let ball = PsychicPlasma(invoker.PlasmaTracker[a]);
			if (!ball) continue;
			else {
				if (!ball.isDead) ball.setStateLabel("Death.Overdrive");
			}
		}
		invoker.PlasmaTracker.Clear();
	}
	
	action Actor A_FireAimedProjectile(class<Actor> missiletype, bool useammo = true, double spawnofs_xy = 0, double spawnheight = 0, int flags = 0)
	{
		let misl = A_FireProjectile(missiletype, 0, useammo, spawnofs_xy, spawnheight, flags, 0);
		if (misl)
		{
			FLineTraceData data;
			Vector3 end;
			bool hit = LineTrace(angle, PLAYERMISSILERANGE, pitch, TRF_SOLIDACTORS|TRF_THRUHITSCAN, player.viewz-pos.z, data: data);
			if (hit && data.hitType != TRACE_CrossingPortal)
				end = (pos.xy, player.viewz) + (AngleToVector(angle,cos(pitch)), -sin(pitch)) * data.distance;
			else
				end = (pos.xy, player.viewz) + (AngleToVector(angle,cos(pitch)), -sin(pitch)) * PLAYERMISSILERANGE;
        
			Vector3 spawnPos = (pos.xy, misl.pos.z);
			if (spawnofs_xy)
				spawnPos.xy = pos.xy + AngleToVector(angle-90)*spawnofs_xy;
        
			Vector3 diff = end - spawnPos;
			double l = diff.Length();
			if (l > 0)
			{
				diff /= l;
				misl.angle = atan2(diff.y, diff.x);
				misl.pitch = -asin(diff.z);
				misl.vel = diff * misl.vel.Length();
			}
		}
    
    return misl;
	}
}

Class PsychicPlasma : PlasmaBall replaces PlasmaBall
{
	bool isDead;

	default {
		+ForceRadiusDmg;
	}

	States
	{
		Death:
			TNT1 A 0 {
				invoker.isDead = true;
			}
			Goto Super::Death;
		Death.Overdrive:
			PLSE A 2 Bright {
				A_StartSound("weapons/elecboom", CHAN_BODY, 0, 1.5);
				A_SetTranslation('PlasmaOverdrive');
				double modifier = Gardevoir(players[consoleplayer].mo).getRageModifier();
				A_PlasmaBlast(BF_DONTWARN | BF_AFFECTBOSSES | BF_NOIMPACTDAMAGE, 255 * modifier, 255 * modifier, 20 * modifier);
				A_SetScale(2.5, 2.5);
			}
			PLSE BC 2 Bright A_StartSound("Weapon/GenericExplode", CHAN_WEAPON);
			PLSE DE 2 Bright;
			stop;
	}
	
	action void PlasmaBlastActor (Actor victim, double strength, double speed, Class<Actor> blasteffect, bool dontdamage)
	{
		if (!victim.SpecialBlastHandling (self, strength))
		{
			return;
		}

		double ang = AngleTo(victim);
		Vector2 move = AngleToVector(ang, speed);
		victim.Vel.XY = move;

		// Spawn blast puff
		ang -= 180.;
		Vector3 spawnpos = victim.Vec3Offset(
			(victim.radius + 1) * cos(ang),
			(victim.radius + 1) * sin(ang),
			(victim.Height / 2) - victim.Floorclip);
		Actor mo = blasteffect? Spawn (blasteffect, spawnpos, ALLOW_REPLACE) : null;
		if (mo)
		{
			mo.Vel.XY = victim.Vel.XY;
		}
		if (victim.bMissile)
		{
			// [RH] Floor and ceiling huggers should not be blasted vertically.
			if (!victim.bFloorHugger && !victim.bCeilingHugger)
			{
				victim.Vel.Z = 8;
				if (mo != null) mo.Vel.Z = 8;
			}
		}
		else
		{
			victim.Vel.Z = 1000. / victim.Mass;
		}
		if (victim.player)
		{
			// Players handled automatically
		}
		else if (!dontdamage)
		{
			victim.bBlasted = true;
		}
		if (victim.bTouchy)
		{ // Touchy objects die when blasted
			victim.bArmed = false; // Disarm
			victim.DamageMobj(self, self, victim.health, 'Melee', DMG_FORCED|DMG_EXPLOSION);
		} else {
			victim.DamageMobj(self, Gardevoir(players[consoleplayer].mo), 16 * (255 / Distance3D(victim)), "Plasma");
			if (victim.health > 0) victim.SetStateLabel('Pain');
		}
	}

	action void A_PlasmaBlast(int blastflags = 0, double strength = 255, double radius = 255, double speed = 20, class<Actor> blasteffect = "BlastEffect", sound blastsound = "BlastRadius")
	{
		A_StartSound (blastsound, CHAN_AUTO);

		if (!(blastflags & BF_DONTWARN))
		{
			SoundAlert (self);
		}
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		while ( (mo = Actor(it.Next ())) )
		{
			//ignore player
			if (Gardevoir(mo)) continue;
			if (mo == self || (mo.bBoss && !(blastflags & BF_AFFECTBOSSES)) || mo.bDormant || mo.bDontBlast)
			{ // Not a valid monster: originator, boss, dormant, or otherwise protected
				continue;
			}
			if (mo.bIceCorpse || mo.bCanBlast)
			{
				// Let these special cases go
			}
			else if (mo.bIsMonster && mo.health <= 0)
			{
				continue;
			}
			else if (!mo.player && !mo.bMissile && !mo.bIsMonster && !mo.bCanBlast && !mo.bTouchy && !mo.bVulnerable)
			{	// Must be monster, player, missile, touchy or vulnerable
				continue;
			}
			if (Distance2D(mo) > radius)
			{ // Out of range
				continue;
			}
			if (mo.CurSector.PortalGroup != CurSector.PortalGroup && !CheckSight(mo))
			{
				// in another region and cannot be seen.
				continue;
			}
			if ((blastflags & 16) && !isVisible(mo, true)) 
			{
				//only blast if target can bee seen by calling actor
				continue;
			}
			PlasmaBlastActor(mo, strength, speed, blasteffect, !!(blastflags & BF_NOIMPACTDAMAGE));
		}
	}
}

Class GHAGCell : CustomInventory replaces Cell
{
	default {
		Inventory.PickupMessage "$GOTCELL";
		inventory.pickupsound "misc/w_pkup";
		Inventory.Amount 20;
	}
	
	override bool TryPickup(Actor toucher)
	{
		let gardie = Gardevoir(Players[consoleplayer].mo);
		
		for (let probe = gardie.Inv; probe != NULL; probe = probe.Inv)
		{
			let item = Cell(probe);
			if (item) {
				if (gardie.countinv('cell') >= item.maxamount) return false;
				else {
					if (gardie.countinv("GHAGPlasmaRifle") == 0)
					{
						gardie.giveInventory("GHAGPlasmaRifle", 1);
						gardie.giveInventory("GHAGPlasmaOverlay", 1);
						if (!gardie.chargingBlackHole) gardie.A_SelectWeapon("GHAGPlasmaRifle");
					}
					gardie.giveInventory("Cell", self.amount);
				}
			}
		}
		GoAwayAndDie();
		return true;
	}
	
	States
	{
		Spawn:
			CELL A -1;
			Stop;
	}
}

Class GHAGCellPack : GHAGCell replaces CellPack
{
	default {
		Inventory.PickupMessage "$GOTCELLBOX";
		inventory.pickupsound "misc/w_pkup";
		Inventory.Amount 100;
	}
	States
	{
		Spawn:
			CELP A -1;
			Stop;
	}
}