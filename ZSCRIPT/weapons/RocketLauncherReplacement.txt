Class GHAGRocketAmmo : CustomInventory replaces RocketAmmo 
{
	default {
		Inventory.pickupmessage "Found a piece of ordnance!";
		Inventory.pickupsound "misc/w_pkup";
		Inventory.amount 1;
	}
	
	override bool TryPickup(Actor toucher)
	{
		let gardie = Gardevoir(Players[consoleplayer].mo);
		
		for (let probe = gardie.Inv; probe != NULL; probe = probe.Inv)
		{
			let item = RocketAmmo(probe);
			if (item) {
				if (gardie.countinv('rocketammo') >= item.maxamount) return false;
				else {
					if (gardie.countinv("GHAGRocketLauncher") == 0) {
						gardie.A_GiveInventory("GHAGRocketLauncher", 1);
						gardie.A_SelectWeapon("GHAGRocketLauncher");
					}
					gardie.A_GiveInventory("RocketAmmo", self.amount);
				}
			}
		}
		GoAwayAndDie();
		return true;
	}
	
	States
	{
		Spawn:
			ROCK A -1;
			Stop;
	}
}

Class GHAGRocketBox : GHAGRocketAmmo replaces RocketBox 
{
	default {
		inventory.pickupmessage "Found a box of ordnance!";
		inventory.pickupsound "misc/w_pkup";
		Inventory.Amount 5;
	}
	States
	{
		Spawn:
			BROK A -1;
			Stop;
	}
}

Class GHAGRocketLauncher : RocketLauncher
{
	default {
		Weapon.AmmoGive 0;
		Weapon.SlotNumber 5;
		+Weapon.NoAlert;
		Tag "Explodey";
		GHAGRocketLauncher.maxRockets 6;
	}
	
	int maxRockets;
	property maxRockets: maxRockets;
	int queuedRockets;
	Array<Int> rocketTracker;
	
	override void DoEffect()
	{
		players[consoleplayer].WeaponState |= WF_WEAPONBOBBING;
		super.DoEffect();
	}
	
	override void tick()
	{
		super.tick();
	}

	States {
		Ready:
			TNT1 A 0 {
				invoker.queuedRockets = 0;
				A_ResetTracker();
				A_Overlay(2, "Speeen");
				A_OverlayFlags(2, PSPF_ADDBOB, false);
				A_OverlayOffset(2, sin(gametic * 2) / 13, cos(gametic * 2) / 11, WOF_ADD | WOF_INTERPOLATE);
			}
		Ready.Speen:
			HAND I 3 {
				invoker.queuedRockets = 0;
				A_ResetTracker();
				if (!Gardevoir(players[consoleplayer].mo).blocking) A_WeaponReady();
				if (countInv("RocketAmmo")) {
					A_OverlayFlags(2, PSPF_ADDBOB, false);
					A_OverlayPivot(2);
					A_OverlayRotate(2, 25, WOF_ADD);
				}
			}
			Loop;
		Deselect:
			HAND I 1 {
				A_Lower();
				if (countInv("RocketAmmo")) {
					A_OverlayFlags(2, PSPF_ADDBOB, false);
					A_OverlayPivot(2);
					A_OverlayRotate(2, 25, WOF_ADD);
				}
			}
			Loop;
		Select:
			HAND I 1 A_Raise();
			TNT1 A 0 {
				A_Overlay(2, "Speeen");
			}
			Loop;
		Fire:
			TNT1 A 0 {
				A_Overlay(2, "Clear");
				A_AlertMonsters();
			}
			RCKF ABCD 2;
			RCKF E 2 A_PsychicMissile();
			RCKF FG 2;
			TNT1 A 0 A_SetNewTagName();
			RCKF HIJKLM 1;
			TNT1 A 0 A_ReFire();
			goto Ready;
		AltFire:
			TNT1 A 0
			{
				if (invoker.queuedRockets >= invoker.maxRockets)
				{
					invoker.queuedRockets = invoker.maxRockets;
					return resolveState('AltFire.AirStrike');
				}
				A_TakeInventory("RocketAmmo", 1);
				invoker.queuedRockets += 1;
				return resolveState(null);
			}
			HAND IIIIIIIIII 1 {
				A_OverlayFlags(2, PSPF_ADDBOB, false);
				A_OverlayPivot(2);
				A_OverlayRotate(2, 25, WOF_ADD);
				A_AnimateQueuedRockets();
				if (countInv("RocketAmmo") == 0) return resolveState('AltFire.AirStrike');
				return resolveState(null);
			}
			TNT1 A 0 A_Refire();
		AltFire.AirStrike:
			TNT1 A 0 {
				A_Overlay(2, "Clear");
				A_AlertMonsters();
			}
			RCKF ABCDEFG 2;
			RCKF G 4 {
				A_PsychicMissile();
				A_SetNewTagName();
			}
		AltFire.RocketLoop:
			RCKF G 4 {
				if (invoker.queuedRockets > 0)
				{
					A_PsychicMissile();
					A_SetNewTagName();
					int layer = A_GetRandomLayer();
					A_Overlay(layer, "Clear");
				}
			}
			TNT1 A 0 
			{
				if (invoker.queuedRockets > 0)
				{
					invoker.queuedRockets -= 1;
					return resolveState('AltFire.RocketLoop');
				}
				else 
				{
					A_ResetTracker();
					return resolveState(null);
				}
			}
			RCKF HIJKLM 1;
			goto Ready;
		RocketQueue:
			SPEN A 3;
			stop;
		Speeen:
			SPEN A 3;
			Loop;
		Clear:
			stop;
	}
	
	action int A_GetRandomLayer()
	{
		int layer = 0;
		while (true)
		{
			layer = random(0, invoker.maxRockets - 1);
			if (invoker.rocketTracker[layer] != 0)
			{
				invoker.rocketTracker[layer] = 0;
				return (3 + layer) * -1;
			}
		}
		return -1;
	}
	
	action void A_ResetTracker()
	{
		invoker.rocketTracker.resize(invoker.maxRockets);
		for (int i = 0; i < invoker.maxRockets; ++i)
		{
			invoker.rocketTracker[i] = 0;
		}
	}
	
	action void A_AnimateQueuedRockets()
	{
		for (int i = 0; i < invoker.queuedRockets; ++i)
		{
			A_Overlay((3 + i) * -1, "Speeen");
			int ypos = ++invoker.rocketTracker[i];
			ypos = min(10, ypos);
			A_OverlayFlags((3 + i) * -1, PSPF_ADDBOB, false);
			A_OverlayPivot((3 + i));
			A_OverlayRotate((3 + i), 25, WOF_ADD);
			int xpos = i % 2 != 0 ? -160 : 20;
			int order = int(i / 2);
			if (order >= 1)
			{
				xpos += (order * 60) * (i % 2 == 0 ? 1 : -1);
				ypos += 20 * order;
			}
			A_OverlayOffset((3 + i) * -1, xpos, 75 - ypos, WOF_ADD | WOF_INTERPOLATE);
		}
	}
	
	action void A_SetNewTagName() 
	{
		Invoker.setTag(Gardevoir(self).getRNGName());
	}
	
	action void A_PsychicMissile() 
	{
		if (player == null)
		{
			return;
		}
		Weapon weap = player.ReadyWeapon;
		if (weap != null && invoker == weap && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weap.DepleteAmmo (weap.bAltFire, true, 1))
				return;
		}
		
		let _locRocket = PsychicRocket(SpawnPlayerMissile("PsychicRocket"));
		if (_locRocket) {
			_locRocket.Vel3DFromAngle(20 + (44 * Gardevoir(self).GetRageModifier()), Gardevoir(self).angle, Gardevoir(self).pitch); 
			_locRocket.modifier = Gardevoir(self).GetRageModifier();
		}
	}
}

Class PsychicRocket : Rocket
{

	double modifier;
	property modifier: modifier;
	
	Default 
	{
		PsychicRocket.modifier 1;
	}

	States {
		Death:
			TNT1 A 0 A_SetScale(1 + modifier, 1 + modifier);
			MISL B 8 Bright A_Explode(100 * (1 + modifier), Max(256, 128 * (1 + modifier)), XF_HURTSOURCE | XF_THRUSTZ);
			MISL C 6 Bright;
			MISL D 4 Bright;
			Stop;
	}
}

Class GrenadeRocket : Rocket
{
	default
	{
		//+Gravity;
	}
}