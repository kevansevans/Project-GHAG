Class Gardevoir : PlayerPawn
{
	int RageTimer;
	int RageConstant;
	int RageValue;
	int RageBonus;
	
	bool OverTheEdge;
	bool charonmode;
	bool chargingBlackHole;
	//property charonmode: charonmode;
	
	default {
		Health 350;
        Player.DisplayName "Gardevoir" ;
		
		Player.StartItem "GHAGPistol";
		Player.StartItem "GHAGPistolOverlay";
		Player.StartItem "Clip", 100;
		Player.StartItem "Shell", 0;
		Player.StartItem "RocketAmmo", 0;
		Player.StartItem "Cell", 0;
		
		Player.StartItem "IcePunch";
		Player.StartItem "Swift";
		Player.StartItem "MoonBlastGun";
		Player.StartItem "BlackHole";
		Player.MaxHealth 350;
		
		Player.ForwardMove 2, 1;
     }
	
	override void BeginPlay()
	{
		Super.BeginPlay();
		
		RageValue = 0;
		Ragetimer = 0;
		RageConstant = 200;
		RageBonus = 0;
		
		OverTheEdge = false;
		charonmode = false;
	}
	
	void subtractAnger(Int value)
	{
		if (OverTheEdge) return;
		
		RageValue -= value;
		if (RageValue < 0) RageValue = 0;
	}
	
	void addAnger(Int value)
	{
		if (OverTheEdge) return;
		
		RageValue += value;
		if (RageValue > RageConstant) RageValue = RageConstant;
	}
	
	int rollCounterAnger;
	void IncreaseAngerRange(Int value)
	{
		rollCounterAnger += value;
	}
	
	void GetLivid()
	{
		if (!overTheEdge) RageValue += 750;
		else RageValue += 250;
		++RageBonus;
	}
	
	int GetRageValue() {
		return RageValue;
	}
	
	double GetRageModifier()
	{
		return GetRageValue() * 0.001 * (v_dashed ? 3 : 1);
	}
	
	double GetTicModifier(int tic, bool allowZero = false) 
	{
		double value = tic * (1 - GetRageModifier());
		if (!allowZero) {
			if (value < 1) value = 1;
		}
		value = round(value);
		return Max(value, 0);
	}
	
	double GetDamageModifier(double damage)
	{
		return damage + (damage * GetRageModifier());
	}
	
	double GetAccuracyModifier(double accuracy)
	{
		return min(max(1, accuracy * (1 - GetRageModifier())), 20);
	}
	
	int restore_kaboom;
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		int _locDamage = damage;
		int _locFlags = flags;
		
		if (RageValue <= RageConstant) {
		
			RageValue += int(damage / 5);
		
			RageTimer = 0;
			if (RageValue > RageConstant) RageValue = RageConstant;
		}
		
		if (!Gardevoir(source)) ActorTracker.trackThing(Source, NONE, damage);
		else
		{
			_locDamage *= 0.25;
		}
		
		let player = Gardevoir(players[consoleplayer].mo);
		
		//Disable revive for now
		/*if (self.health - _locDamage <= 0 && player.countinv("ReviveHalf") >= 1)
		{
			reviveAmount = 175;
			player.takeInventory("ReviveHalf", 1);
			_locDamage = 0;
			//GHAGStatus.hudMessageBox(Cvar.findCvar("name").getString() .. " got in a pinch and had to use a revive!", 10);
		}*/
		
		if (gametic > restore_kaboom && restore_kaboom != -1) bNoRadiusDmg = false;
		
		return Super.DamageMobj(inflictor, source, _locDamage, mod, _locFlags, angle);
	}
	
	override void Tick()
	{
		RageTimer++;
		
		if (rollCounterAnger > 0 && gametic % 2 == 0) {
			RageConstant += 1;
			rollCounterAnger -= 1;
		}
		
		if (RageValue > RageConstant) OverTheEdge = true;
		else if (RageValue <= RageConstant) OverTheEdge = false;
		
		if (rageValue != 0)
		{
			if (!overTheEdge)
			{
				int draintic = int(100 / (rageValue / 10. / 2.)) * 2;
				int drainrate = 1;
				if (ragevalue > 1000 && !overTheEdge)
				{
					int rate = int((ragevalue - 1000) / 100 / 2);
					drainrate += rate;
				}
				if (RageTimer >= (draintic + RageBonus)) {
					ragevalue -= drainrate;
					RageTimer = 0;
				}
			} else if (overTheEdge) {
				if (RageTimer >= (10 + RageBonus)) {
					ragevalue -= 3;
					RageTimer = 0;
				}
			}
		}
		
		
		
		//This script assumes that the map maker has some sort of script
		//that manually gives player items
		if (self.countinv("Pistol") >= 1)
		{
			self.clearInventory();
			
			self.giveInventory("GHAGPistol", 1);
			self.giveInventory("GHAGPistolOverlay", 1);
			self.giveInventory("IcePunch", 1);
			self.giveInventory("Swift", 1);
			self.giveInventory("MoonBlastGun", 1);
			self.giveInventory("BlackHole", 1);
		}
		
		int curArmor = countInv('BasicArmor');
		if (curArmor > prev_armor)
		{
			shield_health += (curArmor - prev_armor);
			shield_health = min(1000, shield_health);
		}
		prev_armor = curArmor;
		
		
		let buttons = player.cmd.buttons;
		double theta = 0;
		double speed = 45;
		
		if (buttons & BT_Speed && shift_tic == -1) {
			shift_tic = gametic;
			dashed = false;
		}
		else if (!(buttons & BT_Speed) && shift_tic != -1) {
			shift_tic = -1;
		}
		
		if (!(buttons & BT_Jump)) {
			if (v_dashed) player.cheats &= ~CF_FROZEN;
			v_dashed = false;
		}
		
		if (player.onGround && buttons & BT_Jump) jumped = true;
		else if (player.onGround) {
			jumped = false;
			v_dashed = false;
			A_StopSound(CHAN_BODY);
		}
		
		if (!player.onGround && jumped && buttons & BT_Jump)
		{
			if (!v_dashed && self.vel.z <= 0)
			{
				self.vel.z = 10;
				v_dashed = true;
				player.cheats |= CF_FROZEN;
				A_Blast(BF_ONLYVISIBLETHINGS);
				A_StartSound("dash/Start", CHAN_AUTO);
			}
					
		}
		
		if (v_dashed && self.vel.z <= 0)
		{
			if (holdpos != self.pos) holdpos = self.pos;
			else {
				self.setOrigin(holdpos, false);
			}
			self.vel.z = 0;
			
			if (buttons & BT_Speed)
			{	
				speed = 20;
				
				A_StartSound("dash/AirLoop", CHAN_BODY, CHANF_LOOP | CHANF_NOSTOP);
				
				if (buttons & BT_MoveLeft) {
					theta = 90;
					if (buttons & BT_Forward && !(buttons & BT_Back)) theta -= 45;
					else if (buttons & BT_Back && !(buttons & BT_Forward)) theta += 45;
				}
				else if (buttons & BT_MoveRight) {
					theta = 270;
					if (buttons & BT_Forward && !(buttons & BT_Back)) theta += 45;
					else if (buttons & BT_Back && !(buttons & BT_Forward)) theta -= 45;
				}
				else if (buttons & BT_Back && !(buttons & (BT_MoveRight | BT_MoveLeft))) theta = 180;
					
				theta += (self.angle % 360);
				
				double thrust_x = min(speed * cos(theta), speed);
				double thrust_y = min(speed * sin(theta), speed);
					
				self.vel.x = thrust_x;
				self.vel.y = thrust_y;
				
				if (gametic % 17 == 0) SubtractAnger(15);
			} 
			else
			{
				A_StopSound(CHAN_BODY);
			
				if (self.vel.x > 0.5) self.vel.x -= 0.3;
				else if (self.vel.x < -0.5) self.vel.x += 0.3;
				else self.vel.x = 0;
				
				if (self.vel.y > 0.5) self.vel.y -= 0.3;
				else if (self.vel.y < -0.5) self.vel.y += 0.3;
				else self.vel.y = 0;
			}
		}
		
		if (shift_tic == -1) dash_timer = 0;
		else
		{
			++dash_timer;
			if (dash_timer >= 5 && dashed == false)
			{
				dashed = true;
			
				if (shift_tic != -1)
				{
					theta = 0;
				}
				
				if (!v_dashed)
				{
					if (buttons & BT_MoveLeft) {
						theta = 90;
						if (buttons & BT_Forward && !(buttons & BT_Back)) theta -= 45;
						else if (buttons & BT_Back && !(buttons & BT_Forward)) theta += 45;
					}
					else if (buttons & BT_MoveRight) {
						theta = 270;
						if (buttons & BT_Forward && !(buttons & BT_Back)) theta += 45;
						else if (buttons & BT_Back && !(buttons & BT_Forward)) theta -= 45;
					}
					else if (buttons & BT_Back && !(buttons & (BT_MoveRight | BT_MoveLeft))) theta = 180;
					
					theta += (self.angle % 360);
					
					double thrust_x = speed * cos(theta);
					double thrust_y = speed * sin(theta);
					
					self.vel.x = thrust_x;
					self.vel.y = thrust_y;
					
					A_StartSound("dash/Start", CHAN_AUTO);
				}
			} 
		}
		
		Super.Tick();
	}
	
	override void PlayerThink()
	{
		super.PlayerThink();
	}
	
	Vector3 holdpos;
	bool dashed;
	bool v_dashed;
	bool jumped;
	int shield_health;
	int dash_timer;
	int shift_tic;
	int prev_armor;
	
	/*override void GiveInventoryType(class<Inventory> _itemToReceive)
	{
		if (_itemToReceive == "Pistol") 
		{
			super.GiveInventoryType("GHAGPistol");
			return;
		}
		
		if (_itemToReceive == "Fist") 
		{
			Super.giveInventoryType("ElementPunch");
			return;
		}
		
		Super.GiveInventoryType(_itemToReceive);
	}*/
	
	override void CheatGive(String _name, int _amount)
	{
		if (_name == 'all')
		{
			if (RageConstant < 1000) RageConstant = 1000;
			else RageConstant += 100;
			
			super.CheatGive("GHAGBackpack", 40);
			super.CheatGive("GHAGBackpack", 40);
			super.CheatGive("all", _amount);
			return;
		}
		
		if (_name == "maxanger")
		{
			RageValue = RageConstant;
			return;
		}
		
		super.CheatGive(_name, _amount);
		
	}
	
	override bool OnGiveSecret(bool print, bool playsound)
	{
		bool rtn = super.OnGiveSecret(print, playsound);
		
		//In the situation a sector fails to spawn a secret,
		//we grant a rage candybar to compensate
		if (self.curSector)
		{
			bool bonus = false;
			Actor mo = self.curSector.thinglist;
			while (mo)
			{
				let c = self.curSector.centerspot;
				if (level.IsPointInLevel((c.x, c.y, self.curSector.floorplane.ZAtPoint(c))))
				{
					bonus = true;
					break;
				}
				mo = mo.snext;
			}
			if (!bonus)
			{
				RageCandyBar(Actor.Spawn('RageCandyBar', self.pos)).touch(self);
			}
		}
		
		return rtn;
	}
}