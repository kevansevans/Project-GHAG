Class Gardevoir : PlayerPawn
{
	int RageTimer;
	int RageDelay;
	int RageConstant;
	int RageValue;
	int RageCooldownTics;
	
	int reviveAmount;
	
	bool OverTheEdge;
	bool charonmode;
	bool chargingBlackHole;
	//property charonmode: charonmode;
	
	int PunchMode;
	property PunchMode: PunchMode;
	
	NameClass names;
	property names: names;
	
	default {
		Health 350;
        Player.DisplayName "Gardevoir" ;
		
		Player.StartItem "GHAGPistol";
		Player.StartItem "GHAGPistolOverlay";
		Player.StartItem "Clip", 100;
		Player.StartItem "Shell", 0;
		Player.StartItem "RocketAmmo", 0;
		Player.StartItem "Cell", 0;
		
		Player.StartItem "IcePunch";
		Player.StartItem "Swift";
		Player.StartItem "MoonBlastGun";
		Player.StartItem "BlackHole";
		Player.MaxHealth 350;
		
		Player.ForwardMove 2, 1;
     }
	
	override void BeginPlay()
	{
		Super.BeginPlay();
		
		RageValue = 0;
		RageDelay = 35 * 3;
		Ragetimer = 0;
		RageConstant = 200;
		RageCooldownTics = 35;
		
		OverTheEdge = false;
		charonmode = false;
		
		PunchMode = 0;
		
		shield_health = 1000;
		prev_armor = 0;
	}
	
	int blades;
	int getBladeCount() 
	{
		for (let inv = inv; inv; inv = inv.inv)
		{
			string wep = '';
			if (inv is "weapon") {
				let saw = GHAGSawBlade(inv);
				if(saw) {
					return saw.ammo1.amount;
				}
			}	
		}
		return -1;
	}
	
	string getRNGName() {
		
		if (!self.names) {
			self.names = NameClass(Spawn("NameClass"));
		}
		return self.names.GetName();
	}
	
	void subtractAnger(Int value)
	{
		if (OverTheEdge) return;
		
		RageValue -= value;
		if (RageValue < 0) RageValue = 0;
	}
	
	void addAnger(Int value)
	{
		if (OverTheEdge) return;
		
		RageValue += value;
		if (RageValue > RageConstant) RageValue = RageConstant;
	}
	
	int rollCounterAnger;
	void IncreaseAngerRange(Int value)
	{
		rollCounterAnger += value;
	}
	
	void GetLivid()
	{
		if (!overTheEdge) RageValue += 750;
		else RageValue += 250;
		RageCooldownTics += 5;
	}
	
	int GetRageValue() {
		return RageValue;
	}
	
	double GetRageModifier()
	{
		return GetRageValue() * 0.001 * (v_dashed ? 3 : 1);
	}
	
	double GetTicModifier(int tic, bool allowZero = false) 
	{
		double value = tic * (1 - GetRageModifier());
		if (!allowZero) {
			if (value < 1) value = 1;
		}
		value = round(value);
		return Max(value, 0);
	}
	
	double GetDamageModifier(double damage)
	{
		return damage + (damage * GetRageModifier());
	}
	
	double GetAccuracyModifier(double accuracy)
	{
		return min(max(1, accuracy * (1 - GetRageModifier())), 20);
	}
	
	int restore_kaboom;
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		int _locDamage = damage;
		int _locFlags = flags;
		
		if (RageValue <= RageConstant) {
		
			RageValue += int(damage / 5);
		
			RageTimer = 0;
			if (RageValue > RageConstant) RageValue = RageConstant;
		}
		
		if (!Gardevoir(source)) ActorTracker.trackThing(Source, NONE, damage);
		else
		{
			_locDamage *= 0.25;
		}
		
		let player = Gardevoir(players[consoleplayer].mo);
		if (self.health - _locDamage <= 0 && player.countinv("ReviveHalf") >= 1)
		{
			reviveAmount = 175;
			player.takeInventory("ReviveHalf", 1);
			_locDamage = 0;
			//GHAGStatus.hudMessageBox(Cvar.findCvar("name").getString() .. " got in a pinch and had to use a revive!", 10);
		}
		
		if (gametic > restore_kaboom && restore_kaboom != -1) bNoRadiusDmg = false;
		
		return Super.DamageMobj(inflictor, source, _locDamage, mod, _locFlags, angle);
	}
	
	override void Tick()
	{
		RageTimer++;
		
		if (RageValue > RageConstant) OverTheEdge = true;
		else if (RageValue <= RageConstant) OverTheEdge = false;
		
		int bonusdelay = 0;
		if (!overTheEdge) 
		{
			bonusDelay = int(RageDelay / 35);
		} 
		else if (OverTheEdge)
		{
			bonusDelay = int(RageDelay / 10);
		}
		
		int slowdown = overTheEdge ? 5 : RageCooldownTics + bonusdelay;
		if (charonmode) {
			RageValue = -999999;
		}
		else if (RageTimer >= slowdown) 
		{
			RageValue -= 3;
			if (RageValue < 0) RageValue = 0;
			RageDelay -= 1;
			if (RageDelay < 0) RageDelay = 0;
			RageTimer = 0;
		}
		
		if (rollCounterAnger > 0 && gametic % 2 == 0) {
			RageConstant += 1;
			rollCounterAnger -= 1;
		}
		
		if (reviveAmount > 0 && gametic % 3 == 0)
		{
			self.giveBody(Min(175 - self.health, 5));
			reviveAmount -= 1;
		}
		
		//This script assumes that the map maker has some sort of script
		//that manually gives player items
		if (self.countinv("Pistol") >= 1)
		{
			self.clearInventory();
			
			self.giveInventory("GHAGPistol", 1);
			self.giveInventory("GHAGPistolOverlay", 1);
			self.giveInventory("IcePunch", 1);
			self.giveInventory("Swift", 1);
			self.giveInventory("MoonBlastGun", 1);
			self.giveInventory("BlackHole", 1);
		}
		
		int curArmor = countInv('BasicArmor');
		if (curArmor > prev_armor)
		{
			shield_health += (curArmor - prev_armor);
			shield_health = min(1000, shield_health);
		}
		prev_armor = curArmor;
		
		
		let buttons = player.cmd.buttons;
		double theta = 0;
		double speed = 45;
		
		if (buttons & BT_Speed && shift_tic == -1) {
			shift_tic = gametic;
			dashed = false;
		}
		else if (!(buttons & BT_Speed) && shift_tic != -1) {
			shift_tic = -1;
		}
		
		if (!(buttons & BT_Jump)) {
			if (v_dashed) player.cheats &= ~CF_FROZEN;
			v_dashed = false;
		}
		
		if (player.onGround && buttons & BT_Jump) jumped = true;
		else if (player.onGround) {
			jumped = false;
			v_dashed = false;
			A_StopSound(CHAN_BODY);
		}
		
		if (!player.onGround && jumped && buttons & BT_Jump)
		{
			if (!v_dashed && self.vel.z <= 0)
			{
				self.vel.z = 10;
				v_dashed = true;
				player.cheats |= CF_FROZEN;
				A_Blast(BF_ONLYVISIBLETHINGS);
				A_StartSound("dash/Start", CHAN_AUTO);
			}
					
		}
		
		if (v_dashed && self.vel.z <= 0)
		{
			if (holdpos != self.pos) holdpos = self.pos;
			else {
				self.setOrigin(holdpos, false);
			}
			self.vel.z = 0;
			
			if (buttons & BT_Speed)
			{	
				speed = 20;
				
				A_StartSound("dash/AirLoop", CHAN_BODY, CHANF_LOOP | CHANF_NOSTOP);
				
				if (buttons & BT_MoveLeft) {
					theta = 90;
					if (buttons & BT_Forward && !(buttons & BT_Back)) theta -= 45;
					else if (buttons & BT_Back && !(buttons & BT_Forward)) theta += 45;
				}
				else if (buttons & BT_MoveRight) {
					theta = 270;
					if (buttons & BT_Forward && !(buttons & BT_Back)) theta += 45;
					else if (buttons & BT_Back && !(buttons & BT_Forward)) theta -= 45;
				}
				else if (buttons & BT_Back && !(buttons & (BT_MoveRight | BT_MoveLeft))) theta = 180;
					
				theta += (self.angle % 360);
				
				double thrust_x = min(speed * cos(theta), speed);
				double thrust_y = min(speed * sin(theta), speed);
					
				self.vel.x = thrust_x;
				self.vel.y = thrust_y;
				
				if (gametic % 17 == 0) SubtractAnger(15);
			} 
			else
			{
				A_StopSound(CHAN_BODY);
			
				if (self.vel.x > 0.5) self.vel.x -= 0.3;
				else if (self.vel.x < -0.5) self.vel.x += 0.3;
				else self.vel.x = 0;
				
				if (self.vel.y > 0.5) self.vel.y -= 0.3;
				else if (self.vel.y < -0.5) self.vel.y += 0.3;
				else self.vel.y = 0;
			}
		}
		
		if (shift_tic == -1) dash_timer = 0;
		else
		{
			++dash_timer;
			if (dash_timer >= 5 && dashed == false)
			{
				dashed = true;
			
				if (shift_tic != -1)
				{
					theta = 0;
				}
				
				if (!v_dashed)
				{
					if (buttons & BT_MoveLeft) {
						theta = 90;
						if (buttons & BT_Forward && !(buttons & BT_Back)) theta -= 45;
						else if (buttons & BT_Back && !(buttons & BT_Forward)) theta += 45;
					}
					else if (buttons & BT_MoveRight) {
						theta = 270;
						if (buttons & BT_Forward && !(buttons & BT_Back)) theta += 45;
						else if (buttons & BT_Back && !(buttons & BT_Forward)) theta -= 45;
					}
					else if (buttons & BT_Back && !(buttons & (BT_MoveRight | BT_MoveLeft))) theta = 180;
					
					theta += (self.angle % 360);
					
					double thrust_x = speed * cos(theta);
					double thrust_y = speed * sin(theta);
					
					self.vel.x = thrust_x;
					self.vel.y = thrust_y;
					
					A_StartSound("dash/Start", CHAN_AUTO);
				}
			} 
		}
		
		Super.Tick();
	}
	
	override void PlayerThink()
	{
		super.PlayerThink();
	}
	
	Vector3 holdpos;
	bool dashed;
	bool v_dashed;
	bool jumped;
	int shield_health;
	int dash_timer;
	int shift_tic;
	int prev_armor;
	
	/*override void GiveInventoryType(class<Inventory> _itemToReceive)
	{
		if (_itemToReceive == "Pistol") 
		{
			super.GiveInventoryType("GHAGPistol");
			return;
		}
		
		if (_itemToReceive == "Fist") 
		{
			Super.giveInventoryType("ElementPunch");
			return;
		}
		
		Super.GiveInventoryType(_itemToReceive);
	}*/
	
	override void CheatGive(String _name, int _amount)
	{
		if (_name == 'all')
		{
			if (RageConstant < 1000) RageConstant = 1000;
			else RageConstant += 100;
			
			super.CheatGive("GHAGBackpack", 40);
			super.CheatGive("GHAGBackpack", 40);
			super.CheatGive("ReviveHalf", 10);
			super.CheatGive("all", _amount);
			return;
		}
		
		if (_name == "maxanger")
		{
			RageValue = RageConstant;
			return;
		}
		
		super.CheatGive(_name, _amount);
		
	}
	
	override bool OnGiveSecret(bool print, bool playsound)
	{
		bool rtn = super.OnGiveSecret(print, playsound);
		
		//In the situation a sector fails to spawn a secret,
		//we grant a rage candybar to compensate
		if (self.curSector)
		{
			bool bonus = false;
			Actor mo = self.curSector.thinglist;
			while (mo)
			{
				if (mo is 'RageCandyBar' || mo is 'ExtraPistol' || mo is 'ExtraShotgun' || mo is 'ExtraPlasma')
				{
					bonus = true;
					break;
				}
				mo = mo.snext;
			}
			if (!bonus)
			{
				RageCandyBar(Actor.Spawn('RageCandyBar', self.pos)).touch(self);
			}
		}
		
		return rtn;
	}
}

Class NameClass : Actor
{

	int getMode;
	int wordtracker;
	
	property getMode: getMode;
	property wordtracker: WordTracker;
	property names: names;
	
	default 
	{
		
		NameClass.getMode 0;
		NameClass.wordTracker 0;

	}
	
	//Your name here? Hit me up!
	static const string names[] =
	{
		"Joey", "Billy", "Kevy", "Kablooey", "Pill", "Martha", "Rachael", "Weasel", "Nash", "Emma",
		"April", "Ghost", "Kekz", "Bob", "Jimmy", "Cali", "Kesha", "Gutawer", "Marisa", "Hugo",
		"Romero", "Carmack", "Adrian", "Tom", "Sandy", "American", "Kid Mystic", "Trouble", "Peace Keeper",
		"Chocolate Thunder", "Vanilla Thunder", "Strawberry Thunder", "Pomegranate Fury", "Fuck you in particular",
		"Death from above", "Oh shit, he", "ASSHAT", "ASSCLOWN", "ASSFART", "RED", "BLUE", "GREEN", "YELLOW", "GOLD", "SILVER",
		"CRYSTAL", "Prof. Oak", "Prof. Elm", "Prof. Birch", "Prof. Rowan", "Prof. Juniper", "Prof. Sycamore", 
		"Prof. Kukui", "Prof. Magnolia", "RUBY", "SAPPHIRE", "EMERALD", "DIAMOND", "PEARL", "PLATINUM", "BLACK", 
		"WHITE", "X", "Y", "SWORD", "SHIELD", "Explosive Diplomacy", "Diplomacy", "Zero Diplomacy", "Fuck you, Baltimore!",
		"Zabivaka, no!", "BASTARD!", "I AM CALM!", "Crocket", "Screaming Eagles!", "The Original", "Stanley",
		"Pikachu", "Shirely", "Surely", "Flynn", "Dacote", "Problem Solver", "Problem Causer", "9K38 Igla", "Bitterman",
		"Rocket", "Rocket No. 524", "Rocky", "Rocky Road", "Rocky Horror", "Not a shiny", "Wonder-trade me", "Fiddlyfaddlybiddlybaddlydiddlydoodlyhiddlyhoodly",
		"Problem Maker", "Problem Deleter", "Kibbles n' bits", "Howler Head", "Dr. Pepper", "Not Safe For Self Propulsion",
		"Safe For Self Propulsion", "Death Bringer", "Funny Name", "Funny Name Here", "Made you look", "Made you explode",
		"ZScript was a mistake", "AEUHHH????", "[No]", "[Added]", "[Already In]", "[DIY]", "[Duplicate]", "[Not Needed]",
		"[Closed]", "[???!?!?!?!????]", "Icon Killer", "This one's for Daisy", "Bottled Up Rage", "Explosive Personality",
		"Explosive Diarrhea", "Bottled Up Rage", "Can of Whoop Ass", "What", "Sin Killer", "MERCILESS EXTERMINATION",
		"SPEEEN", "Merry Christmas", "Apple!", "Hey!", "Apple, hey Apple!", "Adios", "Busting makes me feel good!",
		"Ok I Love You Bye Bye", "Not funny, didn't laugh", "Frag out", "Fire in the hole!", "50 Shades of Explode",
		"50 Shades of you're dead", "50 shades of gibitude", "50 shades of death", "ZoomyPop", "Zoomie Boomies",
		"Congrats! You've won!", "NOT THE BEES!", '"Dildo Joke Here"', "Help I'm trapped in a rocket factory!",
		"Sit down, That means you Billy!", "Lil' smokey", "Ayy Pappie!", "Sparky", "Charging Charlie",
		"Mister Roger's Middle Finger", "Fandango", "The Rectifier", "Buelah", "Chumlee", "Butterface", "Gone Fission",
		"Not your dad's colonoscopy", "Bitch Slap", "The Dreaded CONE", "Bloop", "Muzzle Maggot", "Track Trolls",
		"Breach Creature", "Bore Baby", "Novacaine", "Karma", "Karma Bringer", "Wake Up Call", "Hey! Listen!",
		"I like shorts!", "Hot explosives in your area!", "Happy Accident", "Chaos... Control!", "Chaos... Swiss Roll!",
		"Creeper", "Shoutout to Simpleflips", "Lamb sauce located", "Target Acquired", "Eightball", "Going out with a bang!",
		"Liam", "Olivia", "Noah", "Oliver", "Ava", "Elijah", "Charlotte", "William", "Sophia", "James", "Jesse", "Amelia",
		"Benjamin", "Isabella", "Lucas", "Mia", "Henry", "Evelyn", "Alexander", "Harper", "Bojack", "Princess", "Nguyen",
		"Todd", "Neal McBeal", "Margo Martindale", "Peanut Butter", "Hollyhock", "Judah", "Surprise!", "PK Rocket!",
		"PSY Rocket!", "The perfect gift", "Imp Encounter", "300mb!", "Dud", "Objection!", "Hold it!", "Take that!",
		"Silence!", "Perfect IV", "Laser!", "Caution!", "Goodnight Everybody!", "Helloooooo Nurse!", "Love", "Heart",
		"Brain", "Control", "CAFFEINATE!", "Wake up!", "Smack!", "That's great", "Fuck Hexen", "What is the time?",
		"Archvile repellant", "Raw kit lawn chair", "Hydrate", "Posture check", "You", "Major Arlene", "Kaapeli", "Bridge Burner",
		"Jimmy", "You let me complicate you", "Excuse me", "Ultimate Cup of Coffee", "Try Haxe!", "Bosh", "Bish", "Chaz", "Bailey",
		"Coco", "Finn"
		
	};

	static const string navyseal[] = {
		"the", "fuck", "did", "you", "just", "fucking", "say", "about", "me,", "you", "little", "bitch?"
	};
	
	static const string awman[] = {
		"Ah man", "So", "way", "back", "in", "the", "mine,", "got", "our", "pickaxe", "swingin'", "from", "side", "to", "side!"
	};
	
	static const string shorts[] = {
		"They're comfy,", "And easy to wear!"
	};
	
	static const string spacemonkey[] = {
		"It starts", "With an", "Earth", "Quake", "Birds and Snakes", "an Airplane", "and", "BILLY JOEL", "Is not afraid..."
	};
	
	static const string contempt[] = {
		"humour", "me", "greatly", "with", "your", "arrogance", "and", 'contempt,', "a", "flood", "of", "accusations", "born", "from", "the", "poison", "of", "envy", "and", "smite", "of", "disrespect."
	};
	
	string GetName() {
		
		string rng_name = '[I am error]';
		
		switch (getMode)
		{
			case 0:
				rng_name = NameClass.names[random(0, NameClass.names.size() - 1)];
				if (rng_name == "What") getMode = 1;
				if (rng_name == "Creeper") getMode = 2;
				if (rng_name == "I like shorts!") getMode = 3;
				if (rng_name == "That's great") getMode = 4;
				if (rng_name == "You") getMode = 5;
				break;
			case 1:
				rng_name = NameClass.navyseal[wordtracker];
				wordtracker += 1;
				if (rng_name == "bitch?") {
					getMode = 0;
					wordTracker = 0;
				}
				break;
			case 2:
				rng_name = NameClass.awman[wordtracker];
				wordtracker += 1;
				if (rng_name == "side!") {
					getMode = 0;
					wordTracker = 0;
				}
				break;
			case 3:
				rng_name = NameClass.shorts[wordtracker];
				wordtracker += 1;
				if (rng_name == "And easy to wear!") {
					getMode = 0;
					wordTracker = 0;
				}
				break;
			case 4:
				rng_name = NameClass.spacemonkey[wordtracker];
				wordtracker += 1;
				if (rng_name == "Is not afraid...") {
					getMode = 0;
					wordTracker = 0;
				}
				break;
			case 5:
				rng_name = NameClass.contempt[wordtracker];
				wordtracker += 1;
				if (rng_name == "disrespect.") {
					getMode = 0;
					wordTracker = 0;
				}
				break;
		}
		
		return rng_name;
	}
}